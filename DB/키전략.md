## DB 에서 선택할 수 있는 키 전략
1. RDB 에서 지원하는 기본 전략을 사용할 수 있다.
    - Mysql 의 경우 AUTO_INCREMENT 전략을 사용한다.
    - 장점: 
        - 설정이 편리하다.
        - 성능: 순차적으로 증가하므로, 인덱스 성능이 매우 좋다.
        - 크기: 8바이트 (BigInt) 등으로 크기가 작아 저장 공간 효율적이다.
    - 단점:
        - 분산 환경 확장성이 제한적이다. ID 생성이 단일 DB 인스턴스에 종속적이기 때문에 샤딩(DB 수평 분할) 시 키 중복 문제가 발생한다.
        - 예측 가능성/보안: 순차적이라서 다음 ID를 쉽게 예측할 수 있어, API 등에 노출될 경우 보안에 취약할 수 있다.
        - 배치 처리 불리: JPA 등 ORM 환경에서 엔티티 저장 시 바로 INSERT 쿼리가 실행되어야 ID를 얻을 수 있어, 쓰기 지연이나 배치 삽입에 불리하다. DB와의 통신 횟수를 줄이기 위해서 한 번에 쿼리문을 처리하는데 ID를 알기 위해서는 쿼리를 하나씩 처리해야 하므로 배치 처리에 대한 성능 향상을 얻을 수 없다.

2. UUID 로 설정
    - UUID: 128비트길이의 전역적으로 고유성이 보장된 식별자이다. 
    - 장점:
        - 전역적 고유성: 충돌 없이 여러 서버나 시스템에서 독립적으로 ID를 생성할 수 있어 분산 환경에 매우 유리하다.
        - 보안: 무작위성이 있어 예측이 불가능하므로, 외부에 ID를 노출할 때 보안에 유리하다.
    - 단점:
        - 성능/인덱스
            - AUTO INCREMENT 전략과 같이 순서대로 저장을 한다면 중간 삽입이 되는 경우가 없기 때문에 트리 재구성할 일이 적다. Clustered Index 구조(인덱스 트리의 리프 노드에 데이터가 저장)에서는 디스크에 레코드가 순서대로 저장되기 때문에 페이지 Split 자주 발생하지 않지만 무작위성 키 전략을 하는 경우 순서대로 저장되지 못하기 때문에 Page Split 이 자주 발생한다. 디스크 I/O 가 결국 많아지기 때문에 성능적인 부누에서 좋지 못하다.
            - 문자열의 키의 경우 비교하기 위해서 CPU 자원을 더 오래/많이 사용한다.

        - 크기:
            - 16진수 32자리와 4개의 하이픈으로 구성되어 자동 증가 전략보다 키가 차지하는 공간이 크다.
            - 문자열로 저장 VARCHAR(36): 인간이 읽기 쉽고 디버깅이 용이하지만 차지하는 공간이 많고(36바이트 차지) 검색 속도가 느리다.
            - 바이너리 저장 BINARY(16): 하이픈을 제거한 후 바이너리 형태(2진 데이터)로 저장한다. 차지하는 공간은 적지만 사람이 읽기 어렵다.

3. 분산 환경을 위한 개선된 전략(TSID, ULID, Snokflake ID)
    - TSID
        - [TSID Creator](https://github.com/f4b6a3/tsid-creator)
    - Snowflake ID
    - 둘 중 어떤 것을 사용할 지 결정을 할 때 충돌 여부와 성능을 비교하여 결정한다.
    

